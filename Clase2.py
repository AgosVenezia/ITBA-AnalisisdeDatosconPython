# -*- coding: utf-8 -*-
"""Copia de Clase_2_Analisis_de_Datos.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1YsFlUykdT51gidxOS5s1LwRVCr2BJALY

# **Clase 2: Visualización de datos**

En la clase anterior vimos diferentes formas escribir, leer e interactuar con información de distintas bases de datos. En muchos casos estos resultados deben ser entendidos por una persona para lograr una correcta interpretación de su significado, por lo cual es importante encontrar la forma más efectiva de visualizarlos. 

En esta segunda clase del curso de Análisis de Datos, comenzaremos a visualizar información de manera gráfica. Al momento de mostrar resultados, es útil tener en mente qué característica de los datos se desea resaltar. No se trata de crear un *collage* de datos sino de **transmitir una idea** o un resultado de forma visual para que sea fácilmente interpretable.

Algunas liberías de visualización son:

*   **Matplotlib**
*   **Seaborn**
*   **Plotly**

Pueden leer sobre ellas [aqui](https://www.fusioncharts.com/blog/best-python-data-visualization-libraries/).

Nos focalizaremos en el uso de **maplotlib** ya que es la libería más popular (el uso de otras liberías es similar). Además, esta se ve potenciada mediante el uso conjunto de otra librería llamada **numpy**.


<img src="https://www.ingeniovirtual.com/wp-content/uploads/tipos-de-graficos-y-diagramas-1.jpg" width=550>
"""

# Link a Youtube: https://www.youtube.com/watch?v=1cZwBTRRQrI
# Tema: Bienvenida clase 4. 

from IPython.display import YouTubeVideo
YouTubeVideo('1cZwBTRRQrI', width=800, height=450)  #Video0

"""# **Numpy**
[Numpy](https://numpy.org/) (**Num**-ber **Py**-thon) es la libreria estándar de Python para trabajar con vectores y matrices. Extiende la funcionalidad de Python permitiendo el uso de expresiones vectorizadas (tales como las de **Matlab**, su competencia en el campo de cálculo científico)

<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/1/1a/NumPy_logo.svg/1200px-NumPy_logo.svg.png" width = 450>

# **Maplotlib**
[Matplotlib](https://matplotlib.org/) (**Mat**-h **Plot** **Lib**rary) es la libreria estándar de Python para realizar gráficos de diversos tipos. 

<img src="https://matplotlib.org/_static/logo2.png" width= 500>


<img src="https://s3.amazonaws.com/stackabuse/media/linear-regression-python-scikit-learn-1.png" width=300px>

<img src="https://www.machinelearningplus.com/wp-content/uploads/2018/11/23_DensityPlot_With_Histogram_Matplotlib-min.png" width=300px>

<img src="https://www.machinelearningplus.com/wp-content/uploads/2018/11/29_PyramidPlot_Matplotlib-min.png" width=300px>
<img src="https://www.machinelearningplus.com/wp-content/uploads/2018/11/36_TimeSeries_Peaks_Troughs_Matplotlib-min.png" width=300px>

## Gráfico de funciones (pyplot.plot)
"""

# Link a Youtube: https://www.youtube.com/watch?v=nJn4Nt7MkCQ
# Tema: Gráfico de funciones simples.

from IPython.display import YouTubeVideo
YouTubeVideo('nJn4Nt7MkCQ', width=800, height=450)  #Video1

"""Empezaremos por algo simple, creando el gráfico de una función $y = f(x)$ en el intervalo $x=[0, 1]$. Por ejemplo, si quisieramos hacer el gráfico de la función $f(x)=x^2$ desearíamos obtener algo así:

 <img src="https://raw.githubusercontent.com/IEEESBITBA/Curso-Python/master/_assets/funcion%20cuadratica.png" alt="gráfico función cuadrática" height="300">

Es importante en este momento tomar en cuenta una limitación crucial que tiene la computación, el hecho de que la cantidad de información que puedo manejar es limitada *¿A qué nos referimos con esto?* A que para graficar la función para todos los valores que puede tomar $x$ entre $0$ y $1$, se necesitaría infinita información ya que **hay infinitos valores posibles de $x$ en este intervalo**, por lo tanto habrá infinitos valores de $y$ que corresponden a cada uno de estos.

A partir de esta limitación surge la necesidad de "[discretizar](https://es.wikipedia.org/wiki/Discretizaci%C3%B3n)" la función. En lugar de graficar una curva perfecta para nuestra función, vamos a graficar solamente algunos puntos de ella, y los uniremos con lineas rectas. **Si la cantidad de puntos que graficamos es lo suficientemente alta, la diferencia será imperceptible**.

Vamos a hacer un ejemplo, crearemos cada uno de los puntos a graficar y para eso utilizaremos una lista de las coordenadas $x$ de los puntos y otra lista de la misma longitud con las coordenadas $y$ correspondientes, continuaremos usando el ejemplo anterior: $y = x^2$

"""

# Para este ejemplo elegimos valores de "x" a distancia 0.1 
x = [0.0, 0.1,  0.2,  0.3,  0.4,  0.5,  0.6,  0.7,  0.8,  0.9,  1.0]

# Los valores de "y" son los valores de "x" elevados al cuadrado
y = [0.0, 0.01, 0.04, 0.09, 0.16, 0.25, 0.36, 0.49, 0.64, 0.81, 1.0]

print(x)
print(y)

"""Usando [plt.plot(x, y)](https://matplotlib.org/3.1.1/api/_as_gen/matplotlib.pyplot.plot.html) podemos generar el gráfico de la función.

Es posible incluír muchas curvas superpuestas sobre el mismo gráfico, por lo cual *matplotlib* espera a que se termine de generar cada gráfico y **al final de todo debemos llamar a [plt.show()](https://matplotlib.org/3.1.1/api/_as_gen/matplotlib.pyplot.show.html)** para mostrar todas las curvas generadas. La idea es en el futuro poder realizar distintos gráficos y recién al final de todo llamar una sóla vez a *plt.show()* para mostrar todo junto.
"""

import matplotlib.pyplot as plt

x = [0.0, 0.1,  0.2,  0.3,  0.4,  0.5,  0.6,  0.7,  0.8,  0.9,  1.0]
y = [0.0, 0.01, 0.04, 0.09, 0.16, 0.25, 0.36, 0.49, 0.64, 0.81, 1.0]

plt.plot(x, y)  # plt.plot recibe 2 listas de igual longitud, la primera para el eje X, la segunda para el eje Y
plt.show()      # Luego de generar el gráfico, lo mostramos

"""*¿Notan los segmentos rectos que unen a los puntos de la curva?*

Es probable que sí, sobretodo al hacer zoom. Sin embargo, podemos ver que con muy pocos puntos la curva ya se ve bastante bien. Imagínense que cuando usemos centenas o miles de puntos la curva *discretizada* será prácticamente indistinguible de la original. No obstante, ingresar los valores numéricos a mano es realmente impráctico, por lo cual podemos automatizar la generación de las listas $x$ e $y$ usando [list comprehension](https://www.w3schools.com/python/python_lists_comprehension.asp):
"""

import matplotlib.pyplot as plt

# Cantidad de puntos
n = 11

# x/(n-1) genera valores entre 0 y 1
# ya que x va desde 0 hasta (n-1)
X = [ x/(n-1) for x in range(n) ]
print(X)

# Para cada valor en X calculo la función elegida
Y = [ x**2 for x in X ]
print(Y)

plt.plot(X, Y)    # plt.plot recibe 2 listas de igual longitud, la primera para el eje X, la segunda para el eje Y
plt.show()        # Luego de generar el gráfico, lo mostramos

"""Incluso podríamos definir una función de Python para ayudarnos a graficar una función matemática genérica, volviendo sencillo escribir nuevas expresiones. En el siguiente ejemplo graficamos la función $y = sin(2\pi x)$ haciendo uso de la librería **math**.

*¿En este caso cuántos puntos consideran necesarios para que el gráfico parezca una curva perfecta?*

**Tip:** Prueben cambiar la cantidad de puntos a 5, 10, 20, 50, 100, etc. para ver qué sucede.

"""

import matplotlib.pyplot as plt
import math

def f(x):
  return math.sin( 2 * math.pi * x )

n = 10  # Cantidad de puntos

X = [ x/(n-1) for x in range(n) ] 
Y = [ f(x) for x in X ]

plt.plot(X, Y)    # plt.plot recibe 2 listas de igual longitud, la primera para el eje X, la segunda para el eje Y
plt.show()        # Luego de generar el gráfico, lo mostramos

"""El código puede ser simplificado incluso más mediante el uso de **Numpy**.

Numpy ofrece nuevos tipos de variables que permiten generar *expresiones vectorizadas*. De esta forma podremos crear un vector $x$ con todas las coordenadas y aplicar la función $sin$ a todo el vector *en simultáneo*. Lo que va a sucede es que **la función se aplica a cada elemento por separado**. Asimismo, puedo multiplicar un vector por una constante, sumar una constante a cada componente, multiplicar dos vectores de forma matricial o escalar, sumar dos vectores, y muchas cosas más.

Las operaciones que se realizan *elemento a elemento* son de mucha utilidad, pueden llegar a encontrarlas bajo el nombre *element-wise operations*.

Veamos dos alternativas para crear vectores equiespaciados: [np.arange(start, stop, step)](https://docs.scipy.org/doc/numpy/reference/generated/numpy.arange.html) y [np.linspace(start, stop, num)](https://docs.scipy.org/doc/numpy/reference/generated/numpy.linspace.html):
"""

import numpy as np

# Creamos un arreglo que empieza en 0, llega hasta 1.1 (no inclusivo)
# con incrementos de 0.1 unidades
t1 = np.arange(0, 1.1, 0.1)  

# Creamos un arreglo que empieza en 0, termina en 1 (inclusivo)
# y tiene 11 elementos, es decir, incrementos de 0.1 unidades.
t2 = np.linspace(0, 1, 11)   

print(t1)
print(t2)

"""Con *np.arange()* debemos indicar el salto entre un elemento y otro, mientras que con *np.linspace()* tenemos que indicar la cantidad total de elementos. Además ***np.arange()* no incluye el valor de *stop* en el vector mientras que *np.linspace()* sí.**

Vamos a recrear el gráfico anterior usando *np.linspace()*, *np.sin()* y *np.pi*:
"""

import matplotlib.pyplot as plt
import numpy as np

# Cantidad de puntos
n = 10

X = np.linspace(0, 1, n)
print('X =\n', X,'\n')

# Se calcula la función sobre cada elemento por separado
Y = np.sin( 2 * np.pi * X )
print('Y =\n', Y,'\n')

plt.plot(X, Y)
plt.show()

"""Podemos ver que `2*np.pi` es una constante, por lo que al multiplicarlo por `X` se realiza la multiplicación elemento a elemento. Cada elemento del vector X se multiplica por la misma constante: `2*np.pi`. Luego `np.sin()` calcula el seno, nuevamente, elemento a elemento.

### Mini desafío 1

1. Gráficar en el intervalo de **[-1, 1]** la función [valor absoluto](https://es.wikipedia.org/wiki/Valor_absoluto). Elegir una cantidad apropiada de puntos de acuerdo a su criterio.

 **Tip:** Usar la funcion [np.absolute](https://numpy.org/doc/stable/reference/generated/numpy.absolute.html) de numpy.



2. Gráficar en el intervalo de **[-5, 5]** una [función gaussiana](https://es.wikipedia.org/wiki/Funci%C3%B3n_gaussiana) definida como:

 $$ f(x) = e^{-x^2/2} $$

 **Tip:** Usar la funcion [np.exp](https://docs.scipy.org/doc/numpy/reference/generated/numpy.exp.html) de numpy.
"""

# Parte 1
import numpy as np
import matplotlib.pyplot as plt

# Cantidad de puntos
n = 101

X = np.linspace(-1, 1, n)
Y = np.absolute(X)
plt.plot(X,Y)
plt.show()

#Parte 2
import matplotlib.pyplot as plt
import numpy as np
import math

# Cantidad de puntos
n = 100
x = np.linspace(-5,5,n)
gaussiana = np.exp(-x**2/2)  # Expresión vectorizada, calcula el resultado uno a uno

plt.plot(x, gaussiana)
plt.show()

"""## Personalización de gráficos"""

# Link a Youtube: https://www.youtube.com/watch?v=yp7MabDyKIA
# Tema: Personalización del gráfico. 

from IPython.display import YouTubeVideo
YouTubeVideo('yp7MabDyKIA', width=800, height=450) #Video 2

"""Es posible ejecutar varias veces *plt.plot()* para superponer diferentes gráficos, pero *plt.show()* se ejecuta una sola vez al final del código.

Adicionalmente, **podemos personalizar cada gráfico con un tercer parámetro de la función plt.plot()**, el cual es un string. El contenido del string indicará el tipo de linea y el color. Mostramos un ejemplo donde le cambiamos el tipo de linea agregando los parámetros **m***, **r--**:
"""

import numpy as np
import matplotlib.pyplot as plt 

x = np.arange(0, 2*3.14 , 0.25)
plt.plot(x,np.sin(x),'m*')       # Magenta con estrellas
plt.plot(x,np.cos(x),'r--')      # Rojo linea discontinua
plt.show()

"""En esta tabla obtenida de la documentación de matplotlib pueden ver distintos colores y tipos de línea:


<img src="https://raw.githubusercontent.com/IEEESBITBA/Curso-Python/master/_assets/ColoresLineas.png" height="600px">

También se le puede colocar un *label* a los gráficos, usando el [parámetro](https://realpython.com/python-optional-arguments/) ***label='Mi label'***.

Para que todos los labels se muestren juntos, debemos ejecutar *plt.legend()* después de todos los gráficos, una sóla vez **justo antes** de *plt.show()*.
"""

# Ejemplo 1:

x = np.arange(0, 2*3.14, 0.1)
y1 = np.sin(x)
y2 = np.cos(x)

plt.plot(x, y1, 'b-', label='Seno')    # graficamos función y1
plt.plot(x, y2, 'r-.', label='Coseno') # graficamos función y2
plt.legend() # Le decimos a maplotlib que muestre todos los labels
plt.show()

# Ejemplo 2:

x1 = [1.5, 1.7, 1.95, 2.63, 2.8, 3.9, 4.76]
y1 = [4.02, 4.61, 4.52, 6.35, 6.55, 9.21, 10.5]

x2 = np.arange(0, 8, 1)
y2 = 2*x2 +1

plt.plot(x1, y1, 'bo', label='Valores Medidos')
plt.plot(x2, y2, 'r-.', label='Estimación')
plt.legend()
plt.show()

"""En caso de que no queramos mostrar las curvas superpuestas, podemos crear diferentes gráficos en la pantalla utilizando *plt.subplot(nrows, ncols, index)*.

- *nrows*: Número de filas
- *ncols*: Número de columnas
- *index*: Número entre 1 y nrows*ncols.

**Nota:** Usando [plt.tight_layout()](https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.tight_layout.html) justo antes de *plt.show()* se ajusta automáticamente el espaciado entre los *subplots*. Pueden probar comentando la instrucción en los próximos ejemplos para ver cómo cambia levemente el espaciado.
"""

x = np.arange(0, 2*3.14, 0.1)
y1 = np.sin(x)
y2 = np.cos(x)

plt.subplot(2, 1, 1)   # 2 filas, 1 columna, posición 1
plt.plot(x, y1, 'b-')  # graficamos función y1

plt.subplot(2, 1, 2)   # 2 filas, 1 columna, posición 2
plt.plot(x, y2, 'r-.') # graficamos función y2

plt.tight_layout()     # Ajustar espaciado entre subplots

print('Ejemplo 1:\n')
plt.show()


# Una vez que usamos plt.show() el gráfico se muestra y podemos crear uno nuevo:


plt.subplot(1, 2, 1)   # 1 fila, 2 columnas, posición 1
plt.plot(x, y1, 'b-')  # graficamos función y1

plt.subplot(1, 2, 2)   # 1 fila, 2 columnas, posición 2
plt.plot(x, y2, 'r-.') # graficamos función y2

plt.tight_layout()     # Ajustar espaciado entre subplots

print('\nEjemplo 2:\n')
plt.show()

"""Veamos algunas cosas más que pueden realizarse:
- Con `plt.figure( figsize = (w, h) )` podemos elegir el tamaño de la figura.
- Con `plt.subplots(nrows, ncols)` podemos crear un conjunto de subplots para ser usados más adelante.
- Con `plt.xlabel('xlabel')` y `plt.ylabel('ylabel')` podemos ponerle nombre a los ejes.
- Con `plt.axis([xmin, xmax, ymin, ymax])` podemos elegir los límites de los ejes.
- Con `plt.title('title')` podemos mostrar un título sobre el gráfico.
- Con `plt.grid()` pueden activar una grilla cuadriculada.

Se pueden configurar muchísimos más parámetros, por lo cual les mostrarmos únicamente los que se suelen usar más regularmente. Si necesitan funcionalidades más específicas, puedan encontrarlas en la documentación de [matplotlib.pyplot](https://matplotlib.org/tutorials/introductory/pyplot.html).
"""

x = np.arange(0, 2*3.14, 0.3)
y1 = np.sin(x)
y2 = np.cos(x)

plt.figure(figsize=(12, 4))  # Configuramos el tamaño del gráfico (en pulgadas)

plt.subplot(1, 2, 1)
plt.title("Gráfico azul")
plt.plot(x, y1, 'bo')        # Graficamos la función y1
plt.xlabel('Tiempo')
plt.ylabel('Corriente')

plt.subplot(1, 2, 2)
plt.title("Gráfico rojo")
plt.plot(x, y2, 'r-.')       # Graficamos la función y2
plt.xlabel('Tiempo')
plt.axis([0, 3, -1, 1])      # Elegimos los límites de los ejes
plt.grid(True)               # Activamos la grilla

plt.show()

"""### Mini desafío 2.A

Se pide realizar un gráfico del valor del **Bitcoin** de los últimos 10 años, marcar con un punto el valor máximo del gráfico y calcular cuándo sucedió.

 **Nota:**  
 - Usen la función [pd.read_csv](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.read_csv.html). Un **.csv** funciona prácticamente igual a un **.xlsx**.
 - Los valores a graficar estan la columna "Open" (usando **to_dict("list"**) podrían resolver el problema).

 
"""

! wget  https://raw.githubusercontent.com/IEEESBITBA/Curso-Python/master/Curso_Analisis_de_Datos_Datos/BTC.csv
# WARNING No tiene 10 Años

# Datos extraidos desde https://es.finance.yahoo.com/

import pandas as pd
import matplotlib.pyplot as plt
import matplotlib.dates as mdates
import numpy as np
import time

archivo = pd.read_csv("BTC.csv")        #Leemos el .csv
data = archivo.to_dict("list")          #Pasamos la data a un formato diccionario en lista
cant = len(data["Date"])                #Obtenemos la cantidad de fechas
#Creamos las variables para los ejes x e y
x = []
y = []

#Creamos las variables para el precio mas alto
precio_mas_alto = 0
dia_del_record = ""

#Recorremos la data, y agregamos a nuestros vectores: la fecha en x y en y el precio
for i in range(cant):
  x.append(data["Date"][i])
  y.append(data["Open"][i])

  if y[i] > precio_mas_alto:        #De paso comparamos el precio con el precio mas alto actual
    precio_mas_alto = y[i]
    dia_del_record = x[i]

print("El precio mas alto es:", precio_mas_alto)
print("Sucedio el dia:", dia_del_record)
#Diseñamos el label para poner en el gráfico
record_label = f'Precio Record: {precio_mas_alto:.2f}\nDía del record: {dia_del_record}'

#Creamos el gráfico
plt.figure(figsize=(12, 4))
plt.plot(x, y)
plt.plot(dia_del_record, precio_mas_alto, 'ko', label=record_label)   #Ploteamos un punto, 'ko' le da el tipo de punto, y le asignamos el label
plt.xticks([f'{y}-01-01' for y in range(2015, 2020)]) # Mostrar el primer día de cada año
plt.grid( axis='y' )   # Mostrar una grilla horizontal
plt.legend()           # Mostrar labels
plt.show()

"""### Mini desafío 2.B - Challenge
Se pide realizar un gráfico de la cotización de las acciones diarias de las compañias **Amazon** y **Google** de los últimos 10 años. Encontrar los puntos donde se cruzan los dos gráficos y marcarlos con un punto. Usar dos tipos de línea distintos. 

**Nota:**  
 - Usen la función [read_csv](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.read_csv.html). Recuerden que un **.csv** es prácticamente identico a un **.xlsx**.
 - Los valores a graficar estan la columna *Open* (usando **to_dict("list"**) podrían resolver el problema).

**Tip:** Ya que los gráficos son discretos, para detectar un cruce deberán revisar que la acción que es la más cara hoy sea la que era más barata ayer. Esto es porque sería muy raro que haya un día en el cual ambas acciones tengan *exactamente* el mismo precio. Para interpretar mejor este comentario pueden observar que en la siguiente imagen se producen 2 cruces, pero sólamente en el primero el cruce es *exactamente* sobre el mismo valor:

<img src="https://raw.githubusercontent.com/IEEESBITBA/Curso-Python/master/_assets/CruceDiscreto.png" width = 450>
"""

! wget https://raw.githubusercontent.com/IEEESBITBA/Curso-Python/master/Curso_Analisis_de_Datos_Datos/GOOGLE.csv
! wget https://raw.githubusercontent.com/IEEESBITBA/Curso-Python/master/Curso_Analisis_de_Datos_Datos/AMZN.csv

# Datos extraidos desde https://es.finance.yahoo.com/

import pandas as pd
import matplotlib.pyplot as plt
import numpy as np

googlefile = pd.read_csv("GOOGLE.csv")
amazonfile = pd.read_csv("AMZN.csv")
google = googlefile.to_dict("list")
amazon = amazonfile.to_dict("list")

#print(google['Open'])
#print(amazon['Open'])

plt.figure(figsize=(16, 8))

#Empiezan con el valor del primer dia
gx = [google["Date"][0]]
gy = [google["Open"][0]]
ax = [amazon["Date"][0]]
ay = [amazon["Open"][0]]

crucex = []
crucey = []

for i in range(1, len(google["Date"])): #range empieza desde 1 en vez de 0
  gx.append(google["Date"][i])
  gy.append(google["Open"][i])
  ax.append(amazon["Date"][i])
  ay.append(amazon["Open"][i])

  # Condicional de cruce (son iguales o invirtieron su orden)
  if (ay[i] == gy[i]) or (ay[i] > gy[i] and ay[i-1] < gy[i-1]) or (ay[i] < gy[i] and ay[i-1] > gy[i-1]):
    crucex.append(gx[i])
    crucey.append(gy[i])

plt.plot(gx,gy)
plt.plot(ax,ay)
plt.plot(crucex,crucey, 'k.')

# En el eje X elijo mostrar 1 cada 100 fechas
# Roto las fechas 60° y luego elijo la alineación con el borde derecho del texto
plt.xticks(gx[::100], rotation=60, horizontalalignment='right')

plt.show()

"""## Piecharts





"""

# Link a Youtube: https://www.youtube.com/watch?v=kQ_q1PDyZvw
# Tema: Gráficos de Torta y su personalización. 

from IPython.display import YouTubeVideo
YouTubeVideo('kQ_q1PDyZvw', width=800, height=450)  # Video 3

"""Este gráfico lo realizamos con la siguiente función:


> plt.**pie**($tamaños$)
"""

import matplotlib.pyplot as plt

sizes = [215, 130, 245, 210, 120, 45]
 
plt.pie(sizes)
plt.show()

"""El gráfico por sí sólo no nos dice mucho. Debemos agregar información que destaque lo que queremos transmitir, por lo que estas son algunas de las opciones más útiles para este propósito:

- **explode**: Le indicamos si alguna de las porciones debe estar alejada del centro


"""

import matplotlib.pyplot as plt

sizes = [255, 130, 245, 210, 300]

e = (0.2, 0, 0, 0, 0) # Cuánto separar cada porción
 
plt.pie(sizes, explode=e)

plt.show()

"""- **labels**: Le indicamos el nombre de cada porción.

"""

import matplotlib.pyplot as plt

l = ('Python', 'C++', 'Ruby', 'Java')
sizes = [255, 130, 245, 210]

e = (0.1, 0, 0, 0)  # explode 1st slice
 
plt.pie(sizes, explode=e, labels=l)

plt.show()

"""- **colors**: Le podemos asignar una paleta de color.

"""

import matplotlib.pyplot as plt

l = ('Python', 'C++', 'Ruby', 'Java')
sizes = [255, 130, 245, 210]
c = ['gold', 'yellowgreen', 'lightcoral', 'lightskyblue']

e = (0.1, 0, 0, 0)  # explode 1st slice
 
plt.pie(sizes, explode=e, colors=c, labels=l)

plt.show()

"""- **startangle**: Le indicamos el ángulo de rotación.

"""

import matplotlib.pyplot as plt

labels = 'Python', 'C++', 'Ruby', 'Java'
sizes = [2150, 130, 245, 210]
colors = ['gold', 'yellowgreen', 'lightcoral', 'lightskyblue']

explode = (0.1, 0, 0, 0)  # explode 1st slice
 
plt.pie(sizes, explode=explode, labels=labels, colors=colors,  startangle=0)

plt.show()

"""- **autopct**: Le indicamos que muestre los porcentajes. Este parámetro sigue una sintáxis estándar, para que muestre 1 decimal se usa: "%1.1f%%". De esta forma le indicamos que vamos a mostrar un numero float con 1 decimal y el %% indica que queremos el simbolo %. Se utiliza un doble % porque el primero es usado como [símbolo de escape](https://en.wikipedia.org/wiki/Escape_sequence)."""

import matplotlib.pyplot as plt

labels = ('Python', 'C++', 'Ruby', 'Java')
sizes = [255, 130, 245, 210]
colors = ['gold', 'yellowgreen', 'lightcoral', 'lightskyblue']

explode = (0.1, 0, 0, 0)  # explode 1st slice
 
plt.pie(sizes, explode=explode, labels=labels, colors=colors, autopct='%5.01f%%',  startangle=140)
 #en autopct ponemos como deseamos que se escriban los porcentajes

plt.show()

"""### Mini desafío 3

1. Visualizar usando un piechart la *cuota de mercado* de diferentes compañías que ofrecen un producto (por ejemplo: marcas de celulares). Buscar en internet los valores actuales para el producto que eligieron.
2. Averiguar el color favorito de caramelos Sugus de diferentes amigos o conocidos y visualizar la información con un gráfico piechart, mostrando los colores de cada sección que corresponden al color de caramelo.

![sugus](https://raw.githubusercontent.com/IEEESBITBA/Curso-Python/master/_assets/sugus.jpg)
"""

# Parte 1

import matplotlib.pyplot as plt

labels = ('Apple', 'Samsung', 'Huawei', 'Xiaomi', 'vivo', 'Oppo', 'Lenovo', 'Otros')
sizes = [72.3, 70.4, 56.2, 32.9, 31.5, 31.4, 11.7, 94.7] #Millones de unidades: 2019 Q4
colors = ['silver', 'royalblue', 'orangered', 'orange', 'cornflowerblue', 'green', 'red', 'grey']

fig = plt.figure(figsize=(6, 6))

plt.pie(sizes, labels=labels, colors=colors, autopct='%5.01f%%', pctdistance=0.85, startangle = 90)

# Dibujar un círculo blanco para mejorar la estética del gráfico
centre_circle = plt.Circle((0,0),0.70,fc='white')
fig.gca().add_artist(centre_circle)

plt.show()

# Parte 2

import matplotlib.pyplot as plt

labels = ('Frutilla', 'Menta', 'Anana', 'Limón', 'Manzana', 'Naranja')
sizes = [10, 6, 2, 9, 4, 1]
colors = ['red', 'green', 'blue', 'yellow', 'lime', 'orange']

fig = plt.figure(figsize=(6, 6))

plt.pie(sizes, labels=labels, colors=colors, autopct='%5.01f%%', pctdistance=0.85, startangle=0)

# Dibujar un círculo blanco para mejorar la estética del gráfico
centre_circle = plt.Circle((0,0),0.70,fc='white')
fig.gca().add_artist(centre_circle)

plt.show()

"""**Nota**: Si quieren más información de como mostrar la información efectivamente usando piecharts pueden visitar este [link](https://medium.com/@kvnamipara/a-better-visualisation-of-pie-charts-by-matplotlib-935b7667d77f)

<img src="https://miro.medium.com/max/640/1*ZF-3-ih4QwSVTVXZeVV-iA.gif" width = 450>

## Histogramas
"""

# Link a Youtube: https://www.youtube.com/watch?v=bmsBOQHTxic
# Tema: Histogramas y Stem Plots. 

from IPython.display import YouTubeVideo
YouTubeVideo('bmsBOQHTxic', width=800, height=450)  # Video 4

"""Para realizar un histograma utilizamos la función:

> plt.**hist**(x, bins, propiedades)

- **x**: secuencia de datos
- **bins**: número de separaciones de igual ancho
- **propiedades**: opcional

Veamos un ejemplo:
"""

import matplotlib.pyplot as plt
import numpy as np

rand = np.random.normal(0,2,1000) # Generamos 1000 numeros al azar con distribución normal, con media 0 y desvío estandar 2
plt.hist(rand,20)                 # Creamos un histograma con los numeros al azar, en 20 separaciones
plt.show()

"""Podemos superponer la función a la que tiende la distribución (a modo de ejemplo, no es necesario entender el procedimiento matemático):

**Nota**: Con el parametro **densit=True** indicamos que normalize el histograma, esto hará que la suma de todas las columnas sea igual a 1.
"""

import matplotlib.pyplot as plt
import numpy as np
mu = 0              # Media de la distribución
sigma = 1           # Desvio estandar
var = sigma**2
t = np.arange(-10, 10, 0.01)
y = 1/np.sqrt(2*np.pi)*sigma*np.exp(-(t-mu)**2/(2*sigma**2))
rand = np.random.normal(mu, var, 10000)
plt.hist(rand, 30, density=True)
plt.plot(t, y)
plt.show()

"""Al igual que todos los demás tipos de gráfico, hay muchas configuraciones posibles que se pueden realizar sobre el mismo. Analizar y explicar cada una en detalle puede ser un poco aburrido, por lo cual confiamos en que cuando quieran generar sus propios gráficos con el estilo que deseen puedan investigar en internet y leer la documentación pertinente.

## Stem plots
Un stem plot nos permite graficar puntos, se utiliza de la siguiente manera:


> plt.**stem**(x,y)
"""

import matplotlib.pyplot as plt
import numpy as np

puntos = 10
espacio = 1

inicio = 0 
fin =  5

x = np.linspace(inicio,fin, puntos)
y = x**2 - 4
y2 = -0.5*x**2-4

plt.subplot(2, 1, 1)
plt.stem(x,y)
plt.subplot(2, 1, 2)
plt.stem(x,y2, 'r-')

plt.show()

"""Al igual que los otros tipos de gráficos, podemos personalizar parámetros como el formato de linea (*linefmt*), el formato del punto (*markerfmt*), el formato de la base (*basefmt*) y el nombre (*label*).

**Nota**: Podemos combinar este grafico con un plot común!
"""

import matplotlib.pyplot as plt
import numpy as np

puntos = 10
espacio = 1

inicio = 0 
fin =  5

x = np.linspace(inicio,fin, puntos)
y = x**2-4
y2 = -0.5 * x**2 - 4

plt.stem(x, y , linefmt='g--', markerfmt='go', basefmt='k', label='Ingresos')
plt.stem(x, y2, linefmt='r-.', markerfmt='ro', basefmt='k', label = 'Gastos')
plt.plot(x,y+y2,'b-',label = 'Ganancia')

plt.legend()
plt.show()

"""## Cómo guardar gráficos

"""

# Link a Youtube: https://www.youtube.com/watch?v=G0wX0YFa6xM
# Tema: Guardado de gráficos. 

from IPython.display import YouTubeVideo
YouTubeVideo('0ms7w7Z4CHA', width=800, height=450)  # Video 5

"""¡Todos los gráficos que estuvimos haciendo se pueden guardar como PNG o JPG para compartirlos con el mundo!

Esto lo hacemos con la siguiente función:

> plt.**savefig**(nombre del archivo)

Si están usando Google Colaboratory, el archivo de la imagen aparecerá en la pestaña *Archivos*.

**Notas:**
- **¡Es muy imporante que lo hagan antes de plt.show()** ya que matplotlib habrá enviado el gráfico a la pantalla y este se limpia para hacer otro gráfico!
- Pueden agregar el parámetro opcional **dpi** para obtener la resolución deseada (se especifica el número de puntos por pulgada):
```python
plt.savefig('plot.png', dpi=300)
```



"""

import numpy as np
import matplotlib.pyplot as plt

# valores de los componentes
# genero un vector con tiempos para evaluar las funciones y plotear

t = np.arange(0, 1, 0.01)
y = np.exp(-t*2+1)

y2 = 1.25*np.exp(t*2-1)
plt.figure(figsize=(10,5))
plt.plot(t, y, "green",label="Demanda")
plt.plot(t, y2, "orange",label="Oferta")

plt.ylabel("Cantidad (Millones)")
plt.xlabel("Precio ($)")

# agregamos leyenda
plt.legend(loc="upper left")

# muestro el grafico que prepare
plt.savefig('ofdem.png')
plt.show()

"""### Mini desafío 4

Leer el archivo **notas.xlsx** que tiene en el campo **Notas** los puntajes de alumnos en un examen (van de 0 a 10) y armar un histograma con los datos, guardarlo en un archivo **Notas.png**
"""

! wget "https://raw.githubusercontent.com/IEEESBITBA/Curso-Python/master/Curso_Analisis_de_Datos_Datos/notas.xlsx"

import matplotlib.pyplot as plt
import pandas as pd

archivo = pd.read_excel("notas.xlsx") 

data = archivo.to_dict("list")

# Con plt.figure elegimos el tamaño del gráfico
plt.figure(figsize=(12, 5))

# Debemos elegir bins del 0 al 11 para que los intervalos de bins correspondan
# a los intervalos semi-abiertos:
# [0, 1) [1, 2) [2, 3) ... [10, 11)
# con align elegimos centrar los bins en el 'borde izquierdo' del intervalo
# Con rwidth controlamos el espesor de las barras
# Con zorder elegimos el orden en que se dibujan los elementos gráficos
plt.hist(data["notas"], range(12), align = 'left', rwidth=0.75, zorder=2)

# xticks de 1 en 1, yticks de 10 en 10
plt.xticks(range(0, 11))
plt.yticks(range(0, 130, 10))

# Grilla horizontal, linea punteada, detras del histograma
plt.grid(axis='y', linestyle='--', zorder=1)

plt.savefig('Notas.png')
plt.show()

"""## Otros tipos de gráficos

Nos quedamos con las ganas de hablar de muchos más temas, pero como en algún momento hay que finalizar la clase vamos a ver algunas otras funciones de *matplotlib* en forma resumida, para que estén al tanto de su existencia y puedan investigar más por su propia cuenta si así lo desean. Pueden encontrar muchísimos más ejemplos en la [galería de matplotlib](https://matplotlib.org/stable/gallery/index.html).

### Scatter Plots

Los *scatter plots* nos permiten graficar puntos al igual que, por ejemplo, los stem plots. La diferencia radica en la forma en que se representa la información. Los scatter plots suelen ser usados en investigación para saber si un conjunto de datos presenta tendencias, o si las variables a comparar están correlacionadas de alguna manera.

"""

import numpy as np
import matplotlib.pyplot as plt

N = 50                              # Graficamos N puntos
x = np.random.rand(N)               # Cada eje tiene N valores aleatorios
y = np.random.rand(N)
colors = np.random.rand(N)          # Los colores también son aleatorios
area = (30 * np.random.rand(N))**2  # Al igual que el área de las circunferencias

# Graficamos y en función de x, con las opciones de forma s, colores c, y transparencia alpha
plt.scatter(x, y, s=area, c=colors, alpha=0.5)
# Mostramos el gráfico 
plt.show()

"""Como vemos, si bien la información se representa correctamente, no parece tener mucha utilidad. Ahora veamos lo que pasa cuando existe una cierta correlación entre los datos que representamos. En este caso las variables tienen distribución normal."""

import matplotlib.pyplot as plt
import numpy as np

mu = [0, 0]                          # Valores medios de x e y
cxy = [[1, 1], [1, 2]]               # Matriz de covarianza, [[Cxx, Cxy], [Cyx, Cyy]]
x, y = np.random.multivariate_normal(mu, cxy, 5000).T

plt.scatter(x, y, s=5, alpha=0.5)
plt.show()

"""Aquí podemos ver claramente que **las variables están correlacionadas** (viendo la forma de elipse que se genera en el gráfico). La teoría detrás de la correlación entre variables aleatorias es muy pesada, así que no esperamos que se entienda completamente, pero sí el concepto para representar los datos. ¡Los invitamos a cambiar los valores de las correlaciones entre $x$ e $y$!

**Tips:**
- $C_{ij}$ denota la correlación de $i$ respecto de $j$.
- $C_{ii}$ denota la autocorrelación de la variable aleatoria $i$, y es semejante a la varianza de $i$.

### Color Mesh

Es otra forma de representar datos, pero en lugar de representar el valor $y$ que le corresponde al valor de $x$, le asigna un color al punto $(x,y)$, en base a otro valor $z$. Es muy usado para representar planos de contorno para funciones del estilo $z = f(x,y)$ o, por otro lado, mostrar una representación 2D de una superficie 3D.
"""

import matplotlib.pyplot as plt
from matplotlib.colors import BoundaryNorm
from matplotlib.ticker import MaxNLocator
import numpy as np

dx, dy = 0.05, 0.05                   # Resolución de cada punto

y, x = np.mgrid[slice(1, 5 + dy, dy), # Se crea un espacio 2D con puntos entre 1 y 5, de separación dx y dy
                slice(1, 5 + dx, dx)]

z = np.sin(x)**10 + np.cos(10 + y*x) * np.cos(x)  # Creamos la función z = f(x,y)

z = z[:-1, :-1]                       # El ultimo valor de z está fuera del borde, así que lo eliminamos

plt.pcolormesh(x, y, z)
plt.title('$z = sin(x)^{10} + cos(10 + xy)cos(x) $')

plt.show()

"""También podemos agregar una barra de nivel con los colores para cada valor del gráfico. Para eso usamos las especificaciones **cmap** y **norm**. Para cambiar los colores del mapa, cambiamos **cmap**. Para cambiar la cantidad de niveles del mapa de colores, y agregar los colores, usamos **norm**. A continuación vemos un ejemplo:"""

# Los colores están divididos en niveles
# En este caso agrupamos los colores en 15 niveles, divididos entre el valor máximo y mínimo de z
levels = MaxNLocator(nbins=15).tick_values(z.min(), z.max())
cmap = plt.get_cmap('PiYG')                             # Tipo de mapa
norm = BoundaryNorm(levels, ncolors=cmap.N, clip=True)  # Incluimos las valores para el borde del gráfico

fig, ax = plt.subplots()

im = ax.pcolormesh(x, y, z, cmap=cmap, norm=norm)
fig.colorbar(im, ax=ax)
ax.set_title('$z = sin(x)^{10} + cos(10 + xy)cos(x) $')

plt.show()

"""### 3D Surface

Si un *color mesh* nos queda corto para representar una superficie 3D, podemos representarlo mediante una perspectiva utilizando **plot_surface**:

"""

import matplotlib.pyplot as plt
from matplotlib import cm
from matplotlib.ticker import LinearLocator
import numpy as np

fig, ax = plt.subplots(subplot_kw={"projection": "3d"})

X = np.arange(-5, 5, 0.25)        # Creamos los puntos de los ejes x e y
Y = np.arange(-5, 5, 0.25)
X, Y = np.meshgrid(X, Y)          # meshgrid permite que z sea luego un arreglo bidimencional
Z = np.sin(np.sqrt(X**2 + Y**2))  # z = f(x,y)

surf = ax.plot_surface(X, Y, Z, cmap=cm.coolwarm) # Se plotea la informacion con un mapa de colores cmap

fig.colorbar(surf, shrink=0.5, aspect=5)  # Se agrega una barra de colores en base a los datos

plt.show()                        # Se muestra el gráfico

"""# **¿Cómo seguir después del curso?**

En este curso de Análisis de Datos aprendimos lo suficiente para crear aplicaciones simples, pero de gran utilidad en la visualización de datos. Esperamos que con los conocimientos adquiridos durante estas clases puedan tener una base sólida para poder interpretar y representar datos de interés de la mejor forma posible.

Sin embargo, el universo de cosas para aprender es infinito y nos parece oportuno comentar algunas de las cosas que le puede interesar a todo aquel que quiera seguir especializándose en Python en el futuro, más allá del análisis de datos:

- Clases y Programación Orientada a Objetos:
 - [A Byte of Python](https://python.swaroopch.com/oop.html)
 - [RealPython](https://realpython.com/python3-object-oriented-programming/)
 - [Docs Python](https://docs.python.org/3/tutorial/classes.html)
 - [Video de Matías Bergerman](https://youtu.be/ZB9brIzJU7c)
- Excepciones: instrucciones `try`, `except`, `finally`, `with`:
 - [A Byte Of Python](https://python.swaroopch.com/exceptions.html)
 - [RealPython](https://realpython.com/python-exceptions/)
 - [Docs Python](https://docs.python.org/3/tutorial/errors.html)
- Funciones Lambda:
 - [RealPython](https://realpython.com/python-lambda/)
 - [W3Schools](https://www.w3schools.com/python/python_lambda.asp)
 - [Video de Matías Bergerman](https://youtu.be/4jy4ADH_7i0)
 
## Propuestas de proyectos
En el [último capítulo](https://python.swaroopch.com/what_next.html) del libro A Byte of Python se ofrecen muchos recursos que pueden resultarles muy interesantes: propuestas de proyectos, videos para ver, consejos, tutoriales, recursos para creación de páginas web e interfaces gráficas, y algunas cosas más.

Hacer un proyecto de cierta complejidad definitivamente será un desafío, les proponemos intentar dividir su proyecto en partes, sub-tareas, y resolver cada problema por separado antes de unir todas las partes. También es muy recomendable buscar información e investigar acerca de los temas que no conocen, además de pedir ayuda o preguntar en foros cuando lo necesitan, ¡nadie programa solo!

En [este cuaderno](https://colab.research.google.com/github/IEEESBITBA/Curso-Python/blob/master/Curso_Analisis_de_Datos_Clases/Proyecto_Integrador_Python.ipynb) les proponemos algunas otras ideas de proyectos que se nos ocurrieron por si alguna les llama la atención, que podrían hacer con los conocimientos adquiridos en el curso e investigando algunas herramientas nuevas.

# **Casos de aplicación**

Como conclusión, les mostramos a continuación algunos ejemplos de aplicación de **Python** realizados por miembros del equipo organizador:

### **Herramienta para graficar funciones de transferencia**
*Matías Bergerman, Pedro Carranza Vélez, Pablo González*

Interfaz gráfica hecha con Qt para comparar curvas de transferencia medidas, simuladas y calculadas de forma teórica.

([Código aqui](https://github.com/pabgonzalez/Plot_Tool))


### **Herramienta para diseñar y graficar fitros de señales con distintos tipos de celdas**
*Alejo Figueroa, Alexander Stephan Moldovan Loayza, Matías Tripoli, Gianfranco Muscariello, Tobías Demeco*

Interfaz gráfica hecha con Qt para crear filtros digitales a partir de especificaciones como atenuación mínima y máxima, y frecuencias de corte. Tambien permite agrupar las transeferencias individuales para crear celdas, y grafica las transferencias juntas o separadas.
([Código aqui](https://github.com/AlexStephan/TC_TP_4_5_FILTERTOOL))
### **Hackerank - plataforma de programación**

Hackerank es una plataforma donde los programadores aprenden a programar y entrenan progresivamente sus habilidades. Es muy utilizada por las empresas para hacer recruiting. Les pasamos el link de una competencia de práctica para introducirse a la plataforma

([Link aqui](https://www.hackerrank.com/curso-de-python))

# Ejercitación Integradora
$\newcommand{\dif}{\bigstar}$$\newcommand{\facil}{\color{\green}{\dif}}$ $\newcommand{\pieceofcake}{\color{cyan}{\dif}}$$\newcommand{\medio}{\color{\yellow}{\dif\dif}}$$\newcommand{\media}{\medio}$$\newcommand{\normal}{\medio}$  $\newcommand{\dificil}{\color{\orange}{\dif\dif\dif}}$ $\newcommand{\imposible}{\color{\red}{\dif\dif\dif\dif}}$

## $\facil$ Those three sides
Escribir una función que dibuje un triángulo equilatero, debe recibir 3 parametros: 


-   X,Y: coordenadas del centro
-   L: Largo de los lados
"""

import numpy as np
import matplotlib.pyplot as plt

def plotTriangle(x, y, L):
  height = np.sqrt(3)*L/2
  apothem = height/3
  #Busco los tres puntos de un triangulo equilatero en base al centro geometrico 
  #https://en.wikipedia.org/wiki/Equilateral_triangle
  point1 = [x-L/2, y-apothem]
  point2 = [x+L/2, y-apothem]
  point3 = [x/2, y+height-apothem]
  # Guardo los puntos en forma x,y, y repito el primer punto para que se cierre el triangulo
  xCoord = [point1[0], point2[0], point3[0], point1[0]]
  yCoord = [point1[1], point2[1], point3[1], point1[1]]
  plt.plot(xCoord, yCoord)
  plt.show()
  return

plotTriangle(0, 0, 100)

"""## $\facil$ Caja y Bigote

Vamos a crear un histograma y un <a href="https://matplotlib.org/api/_as_gen/matplotlib.pyplot.boxplot.html">*Box-and-Whisker plot*</a>. 


<center>
<img src="https://matplotlib.org/_images/sphx_glr_boxplot_demo_pyplot_001.png" height=300 title="Box and Whisker plot ejemplo.">
 </center>
 
 Este tipo de gráfico es comunmente utilizado para mostrar la distribución de una muestra poblacional de forma muy visual.

## Código dado
```python
! wget "https://raw.githubusercontent.com/IEEESBITBA/Curso-Python/master/Curso_Analisis_de_Datos_Datos/NotasFinitos.csv"

import pandas as pd
import matplotlib.pyplot as plt
datos = pd.read_csv("NotasFinitos.csv")
print(datos)
```
## Objetivos

### Procesamiento de datos
Procesar Notas de tres parciales (convertirlas a números). Se debería obtener tres listas con notas del 0-140, una para cada uno de los tres parciales. ¡Tengan cuidado que pandas devuelve las notas en formato `string`!

  Función para ver si un valor es `NaN`:
 ```python
 def isNaN(num):
    return num != num
 ```
 
 ### Graficar Histograma
 
El histograma debería tener 5 barras **por cada parcial**.
 
 **Intervalos:**
 * Notas entre 0-30.
 * Notas entre 31-60.
 *  Notas entre 61-90.
 * Notas entre 91-120.
 * Notas entre 121-140.
 
 Esto se puede lograr otorgandole un valor a la propiedad  <a href="https://en.wikipedia.org/wiki/Histogram">`bins` del histograma</a>. 
 
```python
plt.hist([parcial1,parcial2,parcial3], bins=intervalos_superiores ,label=nombreDeDatasets)
```

  ### Graficar Box-and-Whisker plot
 Graficar el *box-and-whisker plot*
 
 ```python
 plt.boxplot([notasParcial1, notasParcial2, notasParcial3])
 ```

 
 
 **Datos y Tips**
 
 * Las notas pueden contener los siguientes valores:
  * `0-140` : Nota numérica.
  * `'Ausente'` : Indica ausencia al parcial.
  * `'NaN'` : El alumno no cumplió condiciones para rendir parcial (celda vacía).
 * Descartar los valores no-numéricos (Ausente y NaN).
 * Usar $\mathrm{int()}$ para convertir valores numericos de `string` a `int`.

"""

def isNaN(num):
   return num != num


def numeralizar(datos):
  datosNumeralizados=[]
  for i in range(len(datos)):
    dato = datos[i]
    if not(isNaN(dato)) and dato != "Ausente":
        datosNumeralizados.append(int(dato))
  return datosNumeralizados


! wget "https://raw.githubusercontent.com/IEEESBITBA/Curso-Python/master/Curso_Analisis_de_Datos_Datos/NotasFinitos.csv"

import pandas as pd
import matplotlib.pyplot as plt
datos = pd.read_csv("NotasFinitos.csv") 

notas1 = datos['1P']
notas2 = datos['2P']
notas3 = datos['3P']

parcial1=numeralizar(notas1)
parcial2=numeralizar(notas2)
parcial3=numeralizar(notas3)


intervalos_superiores=[30,60,90,120,140]
nombreDeDatasets=['Parcial 1','Parcial 2','Parcial 3']
plt.hist([parcial1,parcial2,parcial3], bins=intervalos_superiores ,label=nombreDeDatasets)
plt.legend(loc="upper right")
plt.show()

_=plt.boxplot([parcial1,parcial2,parcial3]) 
# ax1.show()

"""## $\facil$ Análisis en las redes
Se pide graficar en función del tiempo la cantidad de vistas, minutos vistos, likes, y subscriptores ganados de un canal de Youtube. Además, se debe indicar cuándo se produjo el mayor *incremento* de un día hacia otro para cada variable mencionada.

Los datos **reales** se encuentran en un archivo *JSON* obtenido mediante la API de YouTube para el [Canal de YouTube de IEEE-ITBA](https://www.youtube.com/channel/UCpWHvOSiPtDIwIw8Tb_9g6A/featured).

Para convertir la información en el archivo a estructuras de datos conocidas se puede emplear el siguiente código, de forma que no es necesario conocer el formato *JSON*, sólamente trabajar con datos de Python:
```python
import json
json_file = open('youtube_data.json')
data = json.load(json_file)
```

**Tips:**
- Para mostrar las fechas sin que se superpongan, se puede usar `fig, ax = plt.subplots(1)` antes de comenzar a graficar, para luego usar `fig.autofmt_xdate()`. Otra alternativa es rotar el texto con `plt.xticks(rotation=90)`
- ¡Pueden buscar en internet todo lo que necesiten! Si les hace falta realizar cierta tarea que no fue explicada en esta clase pueden encontrar muchas respuestas investigando.
"""

! wget "https://raw.githubusercontent.com/IEEESBITBA/Curso-Python/master/Curso_Analisis_de_Datos_Datos/youtube_data.json"

import json
import matplotlib.pyplot as plt

json_file = open('youtube_data.json')
data = json.load(json_file)

day = []
emw = []
views = []
likes = []
subs = []

# Organizo la información
for day_info in data['rows']:
  day.append(day_info[0])
  emw.append(day_info[1])
  views.append(day_info[2])
  likes.append(day_info[3])
  subs.append(day_info[4])

# Determino el cambio diario
emw_change = [emw[i] - emw[i-1] for i in range(1, len(emw))]
views_change = [views[i] - views[i-1] for i in range(1, len(views))]
likes_change = [likes[i] - likes[i-1] for i in range(1, len(likes))]
subs_change = [subs[i] - subs[i-1] for i in range(1, len(subs))]

fig, (ax1, ax2, ax3, ax4) = plt.subplots(4, figsize=(12, 10))

ax1.plot(day, emw)
i = emw_change.index( max(emw_change) ) + 1  # Máximo cambio
ax1.plot(day[i], emw[i], 'ko', label = 'Máximo cambio: {}\n Día: {}'.format(emw[i],day[i]))
ax1.set_title('Estimated Minutes Watched')
ax1.grid()
ax1.legend()

ax2.plot(day, views)
i = views_change.index( max(views_change) ) + 1
ax2.plot(day[i], views[i], 'ko', label = 'Máximo cambio: {}\n Día: {}'.format(views[i],day[i]))
ax2.set_title('Views')
ax2.grid()
ax2.legend()

ax3.plot(day, likes)
i = likes_change.index( max(likes_change) ) + 1
ax3.plot(day[i], likes[i], 'ko', label = 'Máximo cambio: {}\n Día: {}'.format(likes[i],day[i]))
ax3.set_title('Likes')
ax3.grid()
ax3.legend()

ax4.plot(day, subs)
i = subs_change.index( max(subs_change) ) + 1
ax4.plot(day[i], subs[i], 'ko', label = 'Máximo cambio: {}\n Día: {}'.format(subs[i],day[i]))
ax4.set_title('Subscribers Gained')
ax4.grid()
ax4.legend()

fig.autofmt_xdate()
plt.show()

"""## $\medio$ Venta de pasajes
Python Airlines es la nueva low-cost en el mercado. Parece que todo el mundo quiere volar en esta aerolínea, pero la cantidad de asientos es limitada y la aerolínea no puede comprar nuevos aviones fácilmente. El departamento de ventas tuvo una gran idea (o al menos eso es lo que compañía piensa). Observaron que algunos de viajeros no se presentan para abordar el vuelo, así que van a vender más pasajes que la cantidad de asientos disponibles y confiar en que suficientes pasajeros no se presenten en el aeropuerto como para no tener que impedir el ingreso de pasajeros al avión.

Las características de los vuelos son los siguientes:

- La aerolínea tiene como ganancia neta \\$400 por pasaje vendido, independientemente de que se presente el pasajero.

- Si la cantidad de pasajeros que se presentan es mayor a la cantidad de asientos, la aerolínea debe gastar \\$600 por pasajero extra para poder ofrecer un hotel y una compensación.

- Cada pasajero tiene una probabilidad del 95% de presentarse en el aeropuerto para tomar el vuelo.

- Cada avión tiene capacidad para 222 pasajeros.

Simular 1000 vuelos en los cuales se vendieron exactamente 250 pasajes. Calcular la ganancia neta promedio que se obtiene vendiendo esta cantidad de pasajes (la venta de pasajes siempre produce la misma ganancia, y se debe restar la pérdida por compensación que depende de la cantidad de pasajeros que se presenten).

Repetir el cálculo de la ganancia promedio para distinta cantidad de pasajes vendidos, entre un rango de 222 y 250. Graficar la ganancia promedio en función de la cantidad de pasajes vendidos y mostrar el punto de máxima ganancia.


**Tip:**
- Se puede usar [np.random.rand()](https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.random.rand.html#numpy.random.rand) < 0.95 para determinar si cierto pasajero se presenta o no.
- Usando `mi_lista.index( max(mi_lista) )` se obtiene primero el valor máximo de una lista, y luego se busca el índice en el cual aparece ese valor. De esta forma obtenemos el índice de la lista en el cual se encuentra el valor máximo.
"""

import matplotlib.pyplot as plt
import numpy as np

vendidos = []
ganancias = []

MAX_CAPACIDAD = 222
PASAJES_VENDIDOS = 250
Q_SIMULACIONES = 1000
GANANCIA_NETA_PASAJE = 400
COMPENSACION = 600
PROBABILIDAD_DE_PRESENTE = 0.95

# v es la cantidad de pasajes vendidos
for v in range(MAX_CAPACIDAD, PASAJES_VENDIDOS + 1):
  promedio = 0

  # i es el indice de cada simulacion
  for i in range(Q_SIMULACIONES):
    presentes = 0
    for p in range(v):
      if np.random.rand() < PROBABILIDAD_DE_PRESENTE:  # Determino si la persona p esta presente
        presentes += 1
    if presentes <= MAX_CAPACIDAD:
      promedio += v*GANANCIA_NETA_PASAJE    # Venta del pasaje
    else:
      promedio += v*GANANCIA_NETA_PASAJE - (presentes-MAX_CAPACIDAD)*COMPENSACION   # Venta menos compensación
  promedio /= Q_SIMULACIONES
  ganancias.append(promedio)
  vendidos.append(v)

# Imprimo el valor máximo
imax = ganancias.index(max(ganancias))
print("Al vender", vendidos[imax], "pasajes, se espera ganar: $", ganancias[imax])

plt.figure(figsize=(12, 6))
plt.plot(vendidos, ganancias)
plt.plot(vendidos[imax], ganancias[imax], 'ro')   # Muestro el valor máximo
plt.grid()
plt.show()

"""## $\normal$ Demografía en Argentina

Se pide visualizar la distribución etaria de la población del país. Para ello se cuenta con la información de 2019 en el archivo *PopulationArgentina2019.csv*, en el cual se detalla para cada rango de edades, el número de individuos de sexo femenino y de sexo masculino (estas fueron las únicas dos categorías que fueron contempladas por quién recolectó estos datos). La primer columna '*Age*' tiene los valores '*0-4*', '*5-9*', '*10-14*', '*15-20*', etc. hasta '*100+*' para cada rango de edades. Las siguientes dos columnas son '*M*' y '*F*', contienen el número de hombres y de mujeres en la población respectivamente. Se deben mostrar un *grafico de barras* para hombres y uno para mujeres, mostrando los rangos de edad en el eje horizontal y el **porcentaje** con respecto a la población total en el eje vertical.

**Tip:** Usar [plt.bar(x, height)](https://matplotlib.org/3.2.1/api/_as_gen/matplotlib.pyplot.bar.html) para crear gráficos de barra, el resultado debería asemejarse a la siguiente imagen:

<img src="https://raw.githubusercontent.com/IEEESBITBA/Curso-Python/master/_assets/DistribucionEtariaArg.png" height=300>

Fuentes: https://www.populationpyramid.net/sources
"""

! wget "https://raw.githubusercontent.com/IEEESBITBA/Curso-Python/master/Curso_Analisis_de_Datos_Datos/PopulationArgentina2019.csv"

import matplotlib.pyplot as plt
import pandas as pd

archivo = pd.read_csv("PopulationArgentina2019.csv")
datos = archivo.to_dict('list')
Age = datos['Age']
M = datos['M']
F = datos['F']

total = sum(M) + sum(F)
M_porcentual = [ 100* i/total for i in M ]
F_porcentual = [ 100* i/total for i in F ]

plt.figure(figsize=(16, 8))
plt.subplot(2, 1, 1)
plt.title('Distribución etaria en mujeres')
plt.bar(Age, F_porcentual)
plt.ylabel('Porcentaje')

plt.subplot(2, 1, 2)
plt.title('Distribución etaria en hombres')
plt.bar(Age, M_porcentual)
plt.ylabel('Porcentaje')
plt.show()

"""## $\normal$ Bug Catcher y el disco de la Eutrofia 
**Atención**: *Este problema asume algunos conocimientos básicos de analisis matemático*.

Pasaron 10 años desde que se concretó un acuerdo para la construcción de una fabrica de queso al lado del Lago Nahuel Huapi, a dos kilometros de la ciudad natal de *Bug Catcher*. *Bug Catcher* dice que en ese tiempo el agua del lago ha visto un deterioro en su calidad y esta peticionando ante la ciudad la imposición de regulaciones más estrictas sobre los efluentes del sector industruial.

Pero primero tiene que demostrar este deterioro... *Y así,* Bug Catcher *ha venido a tí para pedirte ayuda, graficando los resultados de un estudio de agua.*

$\newcommand{\zf}{{z_{\mathrm{f}}}}$

---


<center>
<img src="https://static.wikia.nocookie.net/espokemon/images/c/c9/Cazabichos_RAA.png" height=150 title="I catch bugs and stop global conglomerates from getting away with enviromental crimes." ></center>


---


**El estudio**

Se efectua un estudio de <a href="https://en.wikipedia.org/wiki/Trophic_state_index#Eutrophic">turbiedad</a> de agua del tipo <a href="https://en.wikipedia.org/wiki/Secchi_disk">*Secchi*</a> . El estudio consiste en hundir un disco blanco en el cuerpo de agua a estudiar y medir la profundidad $\zf$  a la cual el disco desaparece. Para el estudio se tiene que tener en cuenta la intensidad de la luz sobre el cuerpo de agua $I_0$.



**El problema**

*Bug Catcher* quiere un gráfico que muestre la turbiedad del lago Nahuel Huapi y compararlo a la de otro lago cercano <a href="https://es.wikipedia.org/wiki/Anexo:Definiciones_usuales_en_hidrolog%C3%ADa#Aguas_arriba">*río arriba*</a>. 

**Objetivo**

Graficar la intensidad de luz $I_z$ en el eje vertical a una profundidad $z$ ($z$ en el eje horizontal) para el Nahuel Huapi y el otro lago. 

**Datos**

Rige la ley de <a href="https://en.wikipedia.org/wiki/Beer%E2%80%93Lambert_law">Beer-Lambert</a>:
$$\frac{I_{z}}{I_{0}}=e^{-k z}$$
donde 
* $I_z$ es la intensidad de luz a una profundidad $z$
* $I_0$ es la intensidad de luz sobre la superficie del agua, para un día soleado $I_0\approx 700\  \mathrm{W/m}^2$
* $k$ es el factor de atenuación del agua. Indica turbiedad.

Sabemos que el disco <a href="https://en.wikipedia.org/wiki/Secchi_disk">*Secchi*</a>  de *Bug Catcher* desaparece bajo **56cm** de agua del Nahuel Huapi.  **Para todos los cálculos suponga que la relación** $\frac{I_\zf}{I_0}$ **vale** $10\%$ (para la profundidad a la cual desaparece el disco).

El factor de atenuación del lago *río arriba* fue medido la semana pasada y vale $k_{\mathrm{ra}}=0,009\ \mathrm{cm}^{-1}$.

**Tips:**

* Hay que despejar $k$ y calcularla para el lago Nahuel Huapi antes de graficar.
* La función `log` de la libreria `math` es el logaritmo natural.
* Prueben graficar ambas curvas hasta la profundidad $\zf$ del lago río arriba.
* **Tener una bolígrafo y un cuaderno abierto ayuda.**
"""

import numpy as np
import matplotlib.pyplot as plt
IzIo=0.1
zfNahuel = 56

# despeje (formula)
kNahuel=-np.log(IzIo)/zfNahuel
kRioArriba = 0.009

#despeje (formula)
zfRioArriba = -np.log(IzIo)/kRioArriba

print('Nahuel Huapi k=',kNahuel)
print('Rio Arriba k=',kRioArriba)

# valores de z a gráficar
z = np.arange(0,zfRioArriba,1)

I0= 700

# valores a gráficar
IzNahuel = I0*np.e**(-kNahuel*z)
IzRioArriba = I0*np.e**(-kRioArriba*z)

plt.figure(figsize=(15,9))
plt.plot(z, IzNahuel, "blue",label="Nahuel Huapi")
plt.plot(z, IzRioArriba, "cyan",label="Río arriba")
plt.ylabel("Intensidad Iz [W/m^2]")
plt.xlabel("Profundidad z [cm]")

plt.legend()                                #Habilitamos los labels
plt.title("Abajo con la fabrica")
plt.minorticks_on()
plt.grid(which='minor', linestyle=':', linewidth=0.2, color='black')
#Le asignamos el estilo a la grilla mayor
plt.grid(which='major', linestyle='-', linewidth=0.3, color='black')
plt.show()

"""## $\normal$ Las Algas del Nahuel Huapi (Bug Catcher Continuado)

*Bug Catcher* ha <a href="https://link.springer.com/article/10.1007/BF00041459">encontrado un paper</a> sobre el crecimiento de algas en relación a la intensidad de luz. No entiende los gráficos del paper (porque no estan hechos en Python) pero llega a leer:

* Debajo de una intensidad de $3\%$ de la del sol ($I_0$) el crecimiento de las algas disminuye rapidamente

* entre $3\%$ y $25\%$ las algas crecen bien.

**Objetivo**

Mostrar rango de profundidad a la cual las algas podrían sobrevivir en el Nahuel Huapi en $\color{green}{\textsf{verde}}$ y la zona a partir de la cual sufren en $\color{red}{\textsf{rojo}}$.

**Tips:**
* $\% I_0=\frac{I_{z}}{I_{0}}=e^{-k z}\quad \longrightarrow \quad z = -\frac{\ln(\% I_0)}{k}$  
* Funcion coloreado debajo la curva: `plt.fill_between(zbien, Izbien, color="green", label="Crecimiento bueno")`

**Bonus**

¿Cómo se ve afectada la zona donde sobreviven las algas al modificar el parametro $k$?
"""

Izsuperior = 0.25
Izinferior = 0.03
zinferior= -np.log(Izsuperior)/kNahuel
zsuperior = -np.log(Izinferior)/kNahuel

zbien  = np.arange(zinferior,zsuperior,0.2)
zmal =np.arange(zsuperior,zfRioArriba,0.2) 

Izbien = I0*np.e**(-kNahuel*zbien) 
Izmal = I0*np.e**(-kNahuel*zmal)
plt.fill_between(zbien, Izbien, color="green",label="Crecimiento bueno")

plt.fill_between(zmal, Izmal,color="red",label="Crecimiento malo")
plt.legend(loc="upper right")
plt.show()

"""## $\dificil$ Esos Malditos Mecánicos...
**Intro**

Volodymyr es un profesor de la materia **Elementos Finitos I** en el ITBA. El <a href="https://en.wikipedia.org/wiki/Finite_element_method">método de los elementos finitos</a> consiste en modelar sistemas de sólidos o fluidos mediante una partición del sistema en subsistemas que se resuelven en conjunto según condiciones de borde y condiciones iniciales. 

**Problema**

El segundo cuatrimestre del 2018 Volodymyr tomó 3 parciales y ahora quiere obtener estadísticas y además saber cuales alumnos aprobaron y cuales no. El archivo `NotasFinitos.csv` contiene los datos **reales** de dicha materia sin los nombres de los alumnos. 



---
<center>
<img src="https://grupocarman.com/blog/wp-content/uploads/2014/10/Mallado-por-elementos-finitos.png" title="Un modelo de un motor. En rojo las partes más comprometidas por fuerzas." height=200>
  
  ***La resolución correcta de este ejercicio indica que el programador tiene un sólido conocimiento del manejo de datos y estructuras de control.***
</center>

---


**Objetivos**

Del archivo `"https://raw.githubusercontent.com/IEEESBITBA/Curso-Python/master/Curso_Analisis_de_Datos_Datos/NotasFinitos.csv"` : 

* Obtener promedios para cada parcial.
* Obtener promedio para toda la cursada.
* Obtener promedios de los que aprobaron la materia, para cada parcial.


***Condiciones de Borde***

* Condición de aprobación de parcial:   `Nota>=60`.

* Para aprobar la materia se necesita aprobar 2 parciales y sumar entre los tres parciales: `sumaNotas>=160`.

* Las notas pueden contener los siguientes valores:
  * `0-140` : Nota numérica.
  * `'Ausente'` : Indica ausencia al parcial.
  * `'NaN'` : El alumno no cumplio condiciones para rendir parcial (celda vacia).

* Tomar los valores `Ausente` y `NaN` como `0`. Usar la función $\mathrm{isNaN}$ en el código de arriba.

**Tips:**
* ¡Las funciones pueden ser muy útiles para este ejercicio! 

* Existe una columna de tres números llamada `MAX` con el máximo puntaje por parcial (ordenado de primer parcial a tercer parcial). No hace falta usar este dato para resolver el ejercicio.

* Convertir la nota de `string` a `int` usando la función $\mathrm{int}(Nota)$.


***Hint:*** 

Hay `49` alumnos, `19` aprobaron la materia según el criterio dado.

"""

import pandas as pd

! wget "https://raw.githubusercontent.com/IEEESBITBA/Curso-Python/master/Curso_Analisis_de_Datos_Datos/NotasFinitos.csv"

def isNaN(num):
    return num != num

def getNota(estado):
  #Definimos la forma de tomar cada calificación
  if estado == 'Ausente':
    return 0
  if isNaN(estado):
    return 0
  return int(estado)
  
def aprobado(parcial1,parcial2,parcial3):
  #Definimos las condiciones de borde para aprobar
  if parcial1+parcial2+parcial3<160:
    return False
  if parcial1>=60 and parcial2>=60:
    return True
  elif parcial1>=60 and parcial3>=60:
    return True
  elif parcial2>=60 and parcial3>=60:
    return True
  else:
    return False



# usamos funciones de pandas (es decir no usamos to_dict, se podría resolver también usando to_dict)
datos = pd.read_csv("NotasFinitos.csv") 

notas = [datos['1P'], datos['2P'], datos['3P']]
N = len(notas[0]) # La cantidad de alumnos notasNumericas

sum = [0, 0, 0]                   #Aca guardamos la suma de los parciales
sumAprobados = [0, 0, 0]          #Aca guardamos la suma de los parciales de los alumnos aprobados
alumnosAprobados = 0

for i in range(len(notas[0])):    #Por cada alumno
  nota = [0, 0, 0]              
  for j in range(len(nota)):    
    nota[j] = getNota(notas[j][i])  #Obtengo sus notas de cada parcial
    sum[j] += nota[j]               #Y las sumo al total de TODOS los alumnos
  
  estaAprobado = aprobado(nota[0],nota[1],nota[2])
  if estaAprobado:                  #Si aparte esta aprobado
    alumnosAprobados += 1           #Aumento la cantidad de aprobados
    for j in range(len(sumAprobados)):  
      sumAprobados[j] += nota[j]    #Sumo sus notas al total de los alumnos aprobados
    
prom = []
for i in range(len(sum)):
  prom.append(sum[i]/N)             #Obtengo el promedio de TODOS los alumnos para cada parcial
  
promAprobados = []                  
for i in range(len(sumAprobados)):  #Por cada parcial
  promAprobados.append(sumAprobados[i]/alumnosAprobados) #Obtengo el promedio solo de los aprobados

print('Cantidad alumnos:',N, '  Cantidad alumnos aprobados:',alumnosAprobados)
print('Promedios para parciales: P1=',prom[0],'P2=',prom[1],'P3=',prom[2])
print('Promedios de los aprobados: P1=',promAprobados[0] ,'P2=',promAprobados[1],'P3=',promAprobados[2] )